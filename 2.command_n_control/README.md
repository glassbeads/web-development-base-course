# Блок 2: командная строка

Работа с консолью - основа всего.
-

Знание консоли даже важнее, чем знание языка программирования: языки меняются, а консоль требуется каждому из них.

Кроме того, именно через консоль мы взаимодействуем со средой, в которой наше приложение запускается: с операционной системой.

Работать в ней придётся очень много. У специалистов моего профиля, с уклоном в инфраструктуру, работа в консоли занимает до 90% времени.

Бояться её не нужно. Нужно запоминать встречаемые команды, и постепенно улавливать логику работы в ней.

Блок будет большим. Но, в отличие от двух предыдущих блоков, он будет больше концептуальным, даже теоретическим: мы будем очень мало делать, но - будем очень много обсуждать. Речь наконец-то начинает заходить о тех самых **фундаментальных знаниях**, передача которых и является главной целью курса; а навык взаимодействия с консолью - безусловно фундаментальный для веб-разработки.

Приступим?


- [Вспомнить всё](#вспомнить-всё)
- [Структура команды](#структура-команды)
    + [Кто?](#кто)
    + [Что?](#что)
    + [Как?](#как)
    + [Так как оно называется?](#так-как-оно-называется)
    + [Команды не только в консоли - они везде](#команды-не-только-в-консоли---они-везде)
- [Разобрались?](#разобрались)
    + [Где?](#где)
    + [Переменные среды](#переменные-среды)
        * [Системные](#системные)
        * [Пользовательские](#пользовательские)
- [Итоговый чеклист](#итоговый-чеклист)


## Вспомнить всё
Давайте вспомним все консольные команды, которые мы использовали в предыдущих блоках:
```bash
pip install virtualenv
virtualenv .venv
pip install flask
python hello.py
```

Снова предлагаю вам упражнение на интуицию: окиньте их взглядом, и попробуйте прикинуть, какой компонент каждой команды за что отвечает.


## Структура команды
Консольная команда не просто так называется командой. Представьте себе, что мы с помощью консоли отдаём приказ; если следовать этой умозрительной модели, то такой приказ состоит из следующих вещей, в такой последовательности:
1. Кто должен его выполнить;
2. Что он должен сделать;
3. Опционально - как именно он должен это сделать.

Давайте подробнее разберём каждый из компонентов.


### Кто?
Первым в команде всегда указывается **_исполняемый файл_**, которому отдаётся команда.  
(Ну ладно, почти всегда; мы вернёмся к этому моменту, когда будем изучать интерпретатор `shell` и язык `Bash`. Но пока считайте, что прям всегда-всегда).

**_Исполняемый_** (англ. _executable_, отсюда расширение `.exe` у бинарей в Windows) означает две вещи:
1. Он **_предназначен для исполнения_** - то есть содержит инструкции, предназначенные к исполнению:
   - в бинарном виде (и тогда это то, что мы привыкли называть **_программой_**, или просто _бинарь_);
   - в виде текста (и тогда это **_скрипт_**);
2. У текущего пользователя есть **_права на исполнение_** этого файла.

<details>
    <summary>Раз уж мы упомянули права на файлы</summary>

Они бывают:
- на чтение
- на запись (т.е. изменение/удаление)
- на исполнение

Подробнее остановимся на них в одном из следующих блоков, когда дойдём до обсуждения ОС Linux. При желании можно подробно почитать [здесь](https://en.wikipedia.org/wiki/File_system_permissions).
</details>

_Бинарь_ содержит инструкции в бинарном виде (он [_скомпилирован_](https://en.wikipedia.org/wiki/Binary_file)). Если опустить детали, то при запуске файла эти инструкции попадают непосредственно в оперативную память и там исполняются.

_Скрипт_ (от англ. _script_ - сценарий) - это _текстовый файл_, в котором записана последовательность команд. Команды эти написаны на некоем [скриптовом языке программирования](https://en.wikipedia.org/wiki/Scripting_language). Чтобы стать понятными компьютеру инструкциями, они должны быть сперва [_интерпретированы_](https://en.wikipedia.org/wiki/Interpreter_(computing)). В зависимости от языка написания, скрипт интерпретируется:
- самим интерпретатором командной строки (`cmd` в Windows, `shell` и его производные в Unix)
- каким-то другим интерпретатором (Python, Perl, Javascript, Ruby, etc)

Исполняемые файлы, используемые в командной строке, по-русски также называют _утилитами_, а по-английски - _tools_. Причём независимо от того, текстовые они, или бинарные, и на каком языке написаны.

Посмотрим на конкретных примерах уже знакомых нам команд:
```bash
pip # install virtualenv
virtualenv # .venv
pip # install flask
python # hello.py
```
Ещё раз: исполняемые файлы, или программы, всегда указываются в команде первыми. В данном случае мы отдаём приказы файлам `python`, `pip`, `virtualenv`. Их типы:
- `python` - это _бинарь_ (или _экзешник_, в случае с Windows)
- `virtualenv` - это _скрипт_, написанный на языке Python, и интерпретируемый им же (его можно открыть с помощью блокнота; попробуйте найти его в недрах системы, если интересно, только не редактируйте!)
- `pip` - тоже _скрипт_, написанный на Python

Теперь разберём, _какие именно приказы_ мы им отдали.


### Что?
Ещё раз приведём список команд:
```bash
pip install virtualenv  # установить пакет "virtualenv"
virtualenv .venv        # установить виртуальное окружение в директорию .venv
pip install flask       # установить пакет "flask"
python hello.py         # запустить файл hello.py
```

В случае с `pip` всё понятно. Команда `install` должна установить Python-пакет с названием, которое мы передали.  
<details>
    <summary>Кстати, а какие команды вообще есть у pip?</summary>

Это можно узнать с помощью следующей команды:
```bash
pip --help
```
Ура, мы хоть что-то **_сделали руками_** за этот блок!

Вывод этой команды довольно длинный, но верхняя его часть выглядит вот так:
```
Usage:   
  pip <command> [options]

Commands:
  install                     Install packages.
  download                    Download packages.
  uninstall                   Uninstall packages.
  freeze                      Output installed packages in requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  check                       Verify installed packages have compatible dependencies.
  config                      Manage local and global configuration.
  search                      Search PyPI for packages.
  wheel                       Build wheels from your requirements.
  hash                        Compute hashes of package archives.
  completion                  A helper command used for command completion.
  debug                       Show information useful for debugging.
  help                        Show help for commands.
```
Удобно, правда? Мы можем спросить у утилиты, а что она вообще умеет! Флаг `--help`, и его укороченная версия `-h`, встречается очень часто, и есть почти у всех утилит, с которыми вы будете работать. Обращаться к нему время от времени очень полезно.

`pip`, как и любой [пакетный менеджер](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%B0%D0%BC%D0%B8), умеет много всего: устанавливать пакеты, скачивать их без установки, удалять, выводить список установленных пакетов, показывать их версии, показывать информацию по конкретному пакету, искать пакеты в [глобальном репозитории](https://pypi.org) и так далее. Всё это - команды, которые мы можем ему "отдать".
</details>

В случае с другими двумя утилитами - `python` и `virtualenv` - всё немного иначе. Их особенность в том, что они умеют делать только одну вещь: `python` умеет интерпретировать файлы (а также скрипты в виде строки, т.е. передаваемые напрямую, без файла), а `virtualenv` - создавать виртуальные окружения (а также модифицировать существующие, в одном кейсе, об этом позже). Поэтому в случае с `python` часть "запусти файл" опущена, и мы просто передаём ему имя файла, который нужно запустить. И точно так же мы не говорим `virtualenv` "создай виртуальное окружение", а просто передаём путь к будущей папке.

Консольные программы, которые будут вам встречаться, чаще всего будут принадлежать ко второму типу: они ["делают одну вещь, и делают её хорошо"](https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well). Комбайны вроде `pip` будут встречаться достаточно редко, и в основном это будут либо такие же пакетные менеджеры из других экосистем (языки программирования, операционные системы), либо системы управления программным обеспечением (с такими мы тоже познакомимся в будущем, обычно их имена заканчиваются на `ctl`).


### Как?
В случае с некоторыми утилитами, мы также можем уточнять, как именно выполнять то или иное действие. Или дефолтное действие, то есть то, которое выполняется по умолчанию; как в случае с `virtualenv` - эта утилита **_всегда_** (за исключением всего одного случая) создаёт виртуальное окружение, но может делать это _по-разному_.

Посмотрим, что мы такого можем изменить в поведении этой утилиты. Выполните в консоли:
```bash
virtualenv --help
```

<details>
    <summary>Вывод команды virtualenv --help</summary>

```
Usage: virtualenv [OPTIONS] DEST_DIR

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -v, --verbose         Increase verbosity.
  -q, --quiet           Decrease verbosity.
  -p PYTHON_EXE, --python=PYTHON_EXE
                        The Python interpreter to use, e.g.,
                        --python=python3.5 will use the python3.5 interpreter
                        to create the new environment.  The default is the
                        interpreter that virtualenv was installed with
                        (/usr/local/opt/python/bin/python3.7)
  --clear               Clear out the non-root install and start from scratch.
  --no-site-packages    DEPRECATED. Retained only for backward compatibility.
                        Not having access to global site-packages is now the
                        default behavior.
  --system-site-packages
                        Give the virtual environment access to the global
                        site-packages.
  --always-copy         Always copy files rather than symlinking.
  --relocatable         Make an EXISTING virtualenv environment relocatable.
                        This fixes up scripts and makes all .pth files
                        relative.
  --no-setuptools       Do not install setuptools in the new virtualenv.
  --no-pip              Do not install pip in the new virtualenv.
  --no-wheel            Do not install wheel in the new virtualenv.
  --extra-search-dir=DIR
                        Directory to look for setuptools/pip distributions in.
                        This option can be used multiple times.
  --download            Download pre-installed packages from PyPI.
  --no-download, --never-download
                        Do not download pre-installed packages from PyPI.
  --prompt=PROMPT       Provides an alternative prompt prefix for this
                        environment.
  --setuptools          DEPRECATED. Retained only for backward compatibility.
                        This option has no effect.
  --distribute          DEPRECATED. Retained only for backward compatibility.
                        This option has no effect.
  --unzip-setuptools    DEPRECATED.  Retained only for backward compatibility.
                        This option has no effect.
```
</details>

Как мы уже говорили, здесь нет _команд_, как у `pip,` зато есть большое количество _флагов_. Например:
- флаг `-v` заставляет утилиту в процессе работы выдавать в консоль больше системной информации, чем обычно; это может быть полезно при отладке и решении каких-то проблем
- флаг `-q`, наоборот, подавляет какой-либо вывод; это может быть полезно в скриптах, где стандартный отчёт о прогрессе в создании окружения может быть излишним
- флаг `--no-pip` говорит не устанавливать `pip` в новое окружение
- флаг `--relocatable`: это единственный кейс, в котором `virtualenv` не создаёт новое окружение, а делает существующее мобильным, т.е. полностью независимым от системного интерпретатора (чтобы его можно было, условно говоря, на флешке перетащить на другую рабочую станцию, и там всё работало)

Также есть флаги, в которые мы можем передать какие-либо значения:
- флаг `-p` позволяет указать путь к бинарю интерпретатора, который нужно взять за основу будущего окружения
- флаг `--prompt` позволяет задать префикс для командной строки нового окружения (вместо обычного `(.venv)`)

Полностью команда с набором таких флагов могла бы выглядеть, например, вот так:

```bash
virtualenv -v --no-pip -p /usr/local/bin/python3.8 --prompt='(my awesome venv!)' .venv
```
Вот так мы не просто говорим, _что_ утилита должна сделать, но и даём некие дополнительные инструкции о том, _как_ она должна это сделать.

При встрече с новой утилитой помните, что у неё скорее всего есть флаг `--help`, или его укороченная версия `-h`. Пользуйтесь им!


### Так как оно называется?
На самом деле терминология вокруг некоторых упомянутых выше концептов несколько туманна. Мы и сами иногда использовали несколько терминов для обозначения одного и того же - и это, в целом, не криминал.

Но достаточно часто в литературе, в статьях, а также и просто в работе с некоторыми технологиями в будущем, вы столкнётесь со следующим толкованием:
1. Та часть команды, в которой помещено имя исполняемого файла, для простоты именуется просто **_команда_**. Т.е.: _команда_ `pip`, _команда_ `python`, _команда_ `virtualenv`.
2. Часть, идущая после названия исполняемого файла, называется **_аргументами команды_**. Т.е.:
- _аргументы команды_ `pip`: `install flask --no-cache-dir` (каждый из них - отдельный аргумент)
- _аргумент команды_ `python`: `hello.py`
- _аргумент команды_ `virtualenv`: `.venv`

Я не утверждаю, что эта терминология правильная, и уж 100% не самая точная; скорее - она просто наиболее часто встречается.

В целом же, уверен, что когда вы столкнётесь с тем или иным термином в будущем, вам будет понятно его значение из контекста. А в конечном счёте вы вообще перестанете обращать на это внимание, и будете просто пользоваться ими, не задумываясь о таких вещах.


### Команды не только в консоли - они везде
Любой процесс в операционной системе запускается именно таким образом. Независимо от того, видите вы это, или нет. Даже если вы пользуетесь пользовательским интерфейсом (Windows), под капотом все программы запускаются именно так - некий исполняемый файл, и набор аргументов к нему. В Windows, в Linux, в MacOS - везде.

Чтобы проверить это, вы можете зайти в `Диспетчер задач`, во вкладку `Подробности`, кликнуть правой кнопкой мыши по заголовкам столбцов, кликнуть "Выбрать столбцы", и галочкой отметить пункт "Командная строка". У вас появится одноимённый столбец с полной информацией о том, какой командой был запущен тот или иной процесс.


## Разобрались?
Ох какой большой блок получился! Ну, вроде всё разобрали, что хотели? Теперь-то мы уж точно знаем, что такое консольная команда, из чего она состоит, и всё такое?

Неа. Ещё не всё.

Остался всего один вопрос. Он важный, и довольно объёмный, поэтому мы посвятим ему оставшуюся часть данного блока.

Помните, мы обсудили, что первый элемент команды - это всегда (ну почти всегда) некий _исполняемый файл_?

Надеюсь, найдутся внимательные читатели, у которых в этот момент возникли смутные сомнения, и появился вопрос.

А **где** эти файлы вообще находятся?


### Где?
Почему мы просто вызываем, например, `python`, не задумываясь о том, где он лежит?

Ведь если это файл, то он точно есть где-то, в какой-то папке на файловой системе, - но мы не знаем, где именно! И мы
- не перемещаемся
- не используем никаких ссылок
чтобы до него добраться!

Как это работает?

Действительно, операционная система сама **_знает, где его искать_**. Без этого знания, нам бы приходилось вызывать интерпретатор Python по его относительному или абсолютному пути - что-то вроде этого (примеры для Windows):
- `.venv\Scripts\python.exe` (относительный путь)
- `C:\Users\my_user\PyCharm\ projects\hello\\.venv\Scripts\python.exe` (абсолютный путь)

Выглядит монструозно. Хотя иногда и такое приходится делать, но обычно когда что-то идёт не так.

Операционная система избавляет нас от необходимости прописывать все пути вручную самостоятельно.

Но чтобы понять, как она это делает, нужно обсудить ещё один концепт - с которым вы, возможно, даже сталкивались.


### Переменные среды
Приложения, которые мы запускаем, и утилиты, с которыми мы работаем, запускаются не в вакууме.

Всегда есть некая среда.

Для каждого процесса, в том числе для каждого открытого терминала, ОС предоставляет собственное выделенное _окружение_. Окружение - это некий набор тех самых "знаний", к которым можно обратиться изнутри программы или терминала. Эти "знания" внутри окружения представлены в виде [переменных среды](https://en.wikipedia.org/wiki/Environment_variable). Каждая переменная среды - это просто пара вида `имя=значение`.

Работая с консолью, можно создавать новые "знания" - то бишь переменные - для своего окружения, а также изменять существующие.


#### Системные
Одной из _системных_ переменных среды является переменная `PATH` (`%PATH%` в Windows, `$PATH` в Unix). Эта переменная как раз и содержит список директорий, в которых ОС ищет исполняемые файлы. Именно благодаря ей нам не нужно вбивать полный или относительный путь до утилиты, с которой мы хотим работать.

Как она ещё может использоваться на практике? Например, когда скрипт `.venv\Scripts\activate` (или `.venv/bin/activate`, если у вас Unix) _активирует виртуальное окружение_ в новом окне терминала, он изменяет именно переменную `PATH` - добавляет в неё директорию с локальной инсталляцией интерпретатора Python (которая находится у нас в папке `.venv`). Это позволяет нам:
- работать с локальной инсталляцией, а не с системным интерпретатором
- устанавливать новые Python-пакеты в локальную инсталляцию (и не бояться тем самым сломать системную)

Другие примеры системных переменных среды: `LANG`, `HOME`, `PWD`, `DISPLAY`, `TZ`. Их набор очень сильно зависит от версии и дистрибутива операционной системы, и даже среди разных ОС Linux, например, этот набор будет неодинаковым. Да, они все называются большими буквами - это старое соглашение, чтобы можно было явно отличить их от других данных.


#### Пользовательские
Более того: как уже было сказано, можно создавать свои собственные переменные среды, и использовать их из приложения или утилит. В будущем нам это очень пригодится для конфигурации нашего веб-сервиса, а пока обсудим, как это работает.

Вернёмся к примеру из официальной документации к `flask`. [На главной сайта](https://www.palletsprojects.com/p/flask/) команда запуска выглядит следующим образом:
```bash
env FLASK_APP=hello.py flask run
```
Если у вас ОС семейства Unix (Linux или MacOS), то вы можете попробовать её у себя в консоли, и она запустит наше приложение точно так же, как `python hello.py`!

<details>
    <summary>Почему эта команда не сработает в Windows</summary>

На самом деле сработает, только не с обычным терминалом.

В обычной поставке ОС Windows нет утилиты `env`. Более того, там совершенно другой механизм объявления переменных среды, и провернуть такую магию, как выше (объявить переменную среды только для запускаемого процесса), не получится без костылей.

В одном из следующих блоков мы познакомимся с `Git`, установим его, и вместе с ним у нас появится `Git Bash`. Вот там есть и `env`, и много других полезных вещей, принесённых с юниксов. А Windows, к сожалению, для разработки очень неудобна, и в первую очередь именно из-за отсутствия человеческой консоли.
</details>

Закономерный вопрос: в чём тогда разница?

Другой ~~интерфейс~~ исполняемый файл. Вместо `python`, используется специальный скрипт `flask`, написанный, разумеется, на Python, и установленный в наше виртуальное окружение. В отличие от интерпретатора Python, задача которого - интерпретировать любой скрипт на языке Python, который ему скормили, утилита `flask` умеет делать строго одну вещь: запускать веб-приложение, основанное на фреймворке `flask`.

Но, чтобы запустить его, утилите нужно знать, где оно находится. И вот именно эту информацию она берёт из _переменной среды_ под названием `FLASK_APP`. Если убрать кусок `env FLASK_APP=hello.py` из команды, и попробовать запустить веб-приложение снова, ничего не получится:
```
Error: Could not locate a Flask application. You did not provide the "FLASK_APP" environment variable, and a "wsgi.py" or "app.py" module was not found in the current directory.
```

Утилита так и говорит нам: переменная среды FLASK_APP не задана, а по дефолтным локациям приложение не найдено.

Подсовывать переменные среды прямо в команду может выглядеть несколько несуразно, но пока она одна - с этим можно мириться.

Но серьёзные _продуктовые_ сервисы порой обрастают десятками таких вот _пользовательских переменных среды_. Некоторые могут считывать из окружения больше сотни переменных. Да и даже самые простые сервисы и утилиты могут использовать с десяток-другой, потому что часто это действительно удобно.

О том, как это решается в разработке, мы поговорим в одном из следующих блоков.


## Итоговый чеклист
Вот это марафон. Блок получился вдвое больше предыдущего. У меня ушло больше 6 часов на написание всего этого, а сколько у вас ушло на прочтение? 😉

Не могу обещать, что впредь всегда будет меньше. Где-то точно будет, но, скорее всего, в основном блоки будут близко к подобному объёму. Надеюсь только, что не больше.

Итак. О чём мы узнали за этот блок:
- разобрали консольную команду на составляющие;
- узнали, что такое _исполняемые файлы_, каких типов они бывают;
- узнали, как мы можем говорить исполняемым файлам, что они должны сделать, и как они должны это сделать;
- узнали, как посмотреть, какие команды и флаги можно давать утилитам;
- обсудили общепринятые наименования - **_команда_** и **_аргумент_**;
- разобрались с тем, как операционная система находит исполняемые файлы, к которым мы обращаемся из консоли;
- кратко обсудили системные переменные среды
- чуть подробнее обсудили пользовательские переменные среды, и то, как их используют утилиты в своей работе

В следующем блоке мы наконец-то вернёмся к нашему веб-приложению. Более того: мы наконец-то посмотрим, как оно выглядит вживую!
